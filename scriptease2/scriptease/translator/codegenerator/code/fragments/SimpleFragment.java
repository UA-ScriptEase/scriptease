package scriptease.translator.codegenerator.code.fragments;

import java.util.regex.Pattern;

import scriptease.translator.codegenerator.CharacterRange;
import scriptease.translator.codegenerator.TranslatorKeywordManager;
import scriptease.translator.codegenerator.code.contexts.Context;

/**
 * Represents a location where a single special code token must be generated by
 * the code generator.
 * 
 * @author remiller
 */
public class SimpleFragment extends FormatFragment {
	private String defaultText = "";
	private Pattern legalRange;

	/**
	 * See:
	 * {@link FormatFragment#FormatFragment(String, CharacterRange, char[])}
	 * 
	 * @param label
	 *            The specific simple directive.
	 * @param legalRange
	 *            The allowed range of alphanumeric characters.
	 */
	public SimpleFragment(String label, Pattern legalRange) {
		super(label);
		this.legalRange = legalRange;
	}

	/**
	 * Creates a clone of the given directive fragment.
	 * 
	 * @param other
	 *            the fragment to copy.
	 */
	public SimpleFragment(SimpleFragment other) {
		this(other.getDirectiveText(), other.getLegalRange());
	}

	/**
	 * Creates a new instance that uses the given directive, and the range and
	 * specials from the other instance.
	 * 
	 * @param label
	 *            The specific simple directive.
	 * @param other
	 *            the fragment to copy.
	 */
	public SimpleFragment(String label, SimpleFragment other) {
		this(label, other.getLegalRange());
	}

	@Override
	public String resolve(Context context) {
		super.resolve(context);
		final String dataLabel = this.getDirectiveText();

		// IF+ELSE BLOCK (fragment data = <dataLabel>)
		if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_NAME_FORMAT))
			return context.getUniqueName(this.legalRange);
		else if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_TYPE_FORMAT)) {
			String type = context.getType();
			if (type.equalsIgnoreCase(Context.UNIMPLEMENTED+": getType")
					&& !defaultText.isEmpty())
				return defaultText;
			else
				return type;
		} else if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_CODE_FORMAT))
			return context.getCode();
		else if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_VALUE_FORMAT)) {
			return context.getValue();
		} else if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_CONDITION_FORMAT))
			return context.getCondition();
		else if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_FORMATTED_VALUE))
			return context.getFormattedValue();
		else if (dataLabel.equalsIgnoreCase(TranslatorKeywordManager.XML_INCLUDE))
				return context.getInclude();
		else if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_SUBJECT))
			return context.getSubject().getBinding().getScriptValue();
		else if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_COMMITTING))
			return context.getCommitting();
		else if (dataLabel.equalsIgnoreCase(TranslatorKeywordManager.XML_FANIN))
			return context.getFanIn();
		else if (dataLabel
				.equalsIgnoreCase(TranslatorKeywordManager.XML_QUEST_CONTAINER))
			return context.getQuestContainer();
		return "<Simple Fragment was unable to be resolved for data: "
				+ dataLabel + " >";
	}

	public final Pattern getLegalRange() {
		return this.legalRange;
	}

	/**
	 * Sets the default text.
	 * 
	 * @param defaultText
	 *            The new text to use as a default.
	 */
	public void setDefaultText(String defaultText) {
		this.defaultText = defaultText;
	}

	public String getDefaultText() {
		return this.defaultText;
	}

	@Override
	public String toString() {
		return "SimpleFragment [" + this.getDirectiveText() + "]";
	}

	public void setLegalRange(Pattern compile) {
		this.legalRange = compile;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj instanceof SimpleFragment) {
			return this.hashCode() == obj.hashCode();
		}
		return false;
	}

	@Override
	public int hashCode() {
		return super.hashCode() + this.defaultText.hashCode()
				+ this.legalRange.hashCode();
	}
}
