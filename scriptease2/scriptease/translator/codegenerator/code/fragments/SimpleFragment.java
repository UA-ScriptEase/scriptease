package scriptease.translator.codegenerator.code.fragments;

import java.util.regex.Pattern;

import scriptease.translator.codegenerator.CharacterRange;
import scriptease.translator.codegenerator.CodeGenerationException;
import scriptease.translator.codegenerator.TranslatorKeywordManager;
import scriptease.translator.codegenerator.code.contexts.Context;

/**
 * Represents a location where a single special code token must be generated by
 * the code generator.
 * 
 * An example of these code tokens are a DoIt's name, type, etc that appear in
 * the language dictionary, although anything defined as a fragment in the
 * language dictionary is a simple fragment.
 * 
 * @author remiller
 */
public class SimpleFragment extends FormatFragment {
	private String defaultText = "";
	private Pattern legalRange;

	/**
	 * See:
	 * {@link FormatFragment#FormatFragment(String, CharacterRange, char[])}
	 * 
	 * @param label
	 *            The specific simple directive.
	 * @param legalRange
	 *            The allowed range of alphanumeric characters.
	 */
	public SimpleFragment(String label, Pattern legalRange) {
		super(label);
		this.legalRange = legalRange;
	}

	/**
	 * Creates a clone of the given directive fragment.
	 * 
	 * @param other
	 *            the fragment to copy.
	 */
	public SimpleFragment(SimpleFragment other) {
		this(other.getDirectiveText(), other.getLegalRange());
	}

	/**
	 * Creates a new instance that uses the given directive, and the range and
	 * specials from the other instance.
	 * 
	 * @param label
	 *            The specific simple directive.
	 * @param other
	 *            the fragment to copy.
	 */
	public SimpleFragment(String label, SimpleFragment other) {
		this(label, other.getLegalRange());
	}

	@Override
	public String resolve(Context context) {
		super.resolve(context);
		final String dataLabel = this.getDirectiveText();
		String resolveString = "";
		try {
			// IF+ELSE BLOCK (fragment data = <dataLabel>)
			if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_NAME_FORMAT))
				resolveString = context.getUniqueName(this.legalRange);
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_TYPE_FORMAT)) {
				try {
					resolveString = context.getType();
				} catch (CodeGenerationException e) {
					if (!defaultText.isEmpty())
						return defaultText;
					else
						throw e;
				}
			} else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_CODE_FORMAT))
				resolveString = context.getCode();
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_VALUE_FORMAT))
				resolveString = context.getValue();
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_CONDITION_FORMAT))
				resolveString = context.getCondition();
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_FORMATTED_VALUE))
				resolveString = context.getFormattedValue();
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_INCLUDE_FORMAT))
				resolveString = context.getInclude();
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_SUBJECT))
				resolveString = context.getSubject().getBinding()
						.getScriptValue();
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_COMMITTING))
				resolveString = context.getCommitting();
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_FANIN))
				resolveString = context.getFanIn();
			else if (dataLabel
					.equalsIgnoreCase(TranslatorKeywordManager.XML_QUEST_CONTAINER))
				resolveString = context.getQuestContainer();
			else
				throw (new CodeGenerationException(
						"Simple Fragment was unable to be resolved for data: "
								+ dataLabel + ">"));

			return resolveString;
		} catch (CodeGenerationException e) {
			return "Error when inserting new simple fragment: " + dataLabel
					+ " with message: " + e.getMessage();
		}
	}

	public final Pattern getLegalRange() {
		return this.legalRange;
	}

	/**
	 * Sets the default text.
	 * 
	 * @param defaultText
	 *            The new text to use as a default.
	 */
	public void setDefaultText(String defaultText) {
		this.defaultText = defaultText;
	}

	public String getDefaultText() {
		return this.defaultText;
	}

	@Override
	public String toString() {
		return "SimpleFragment [" + this.getDirectiveText() + "]";
	}

	public void setLegalRange(Pattern compile) {
		this.legalRange = compile;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj instanceof SimpleFragment) {
			return this.hashCode() == obj.hashCode();
		}
		return false;
	}

	@Override
	public int hashCode() {
		return super.hashCode() + this.defaultText.hashCode()
				+ this.legalRange.hashCode();
	}
}
